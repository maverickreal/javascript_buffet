<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c1{background-color:#24292e;padding-top:0pt;padding-bottom:0pt;line-height:1.35;orphans:2;widows:2;text-align:left}.c0{font-size:15pt;font-family:"Courier New";color:#79b8ff;font-weight:400}.c8{font-size:15pt;font-family:"Courier New";color:#ffab70;font-weight:400}.c2{font-size:15pt;font-family:"Courier New";color:#e1e4e8;font-weight:400}.c6{font-size:15pt;font-family:"Courier New";color:#f97583;font-weight:400}.c4{font-size:15pt;font-family:"Courier New";color:#b392f0;font-weight:400}.c7{font-size:15pt;font-family:"Courier New";color:#9ecbff;font-weight:400}.c5{color:#6a737d;font-weight:400;font-size:15pt;font-family:"Courier New"}.c3{text-decoration:none;vertical-align:baseline;font-style:normal}.c9{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c9"><p class="c1"><span class="c5 c3">//SPECIAL DATA TYPES</span></p><p class="c1"><span class="c5 c3">/* BigInt - This data type is used to store numbers which are above the limitation of the Number data type.It can store large integers and is represented by adding &ldquo;n&rdquo; to an integer literal.</span></p><p class="c1"><span class="c5 c3">Example : */</span></p><p class="c1"><span class="c6">const</span><span class="c2">&nbsp;</span><span class="c0">previouslyMaxSafeInteger</span><span class="c2">&nbsp;</span><span class="c6">=</span><span class="c2">&nbsp;</span><span class="c0">9007199254740991</span><span class="c6 c3">n</span></p><p class="c1"><span class="c6">const</span><span class="c2">&nbsp;</span><span class="c0">alsoHuge</span><span class="c2">&nbsp;</span><span class="c6">=</span><span class="c2">&nbsp;</span><span class="c0">BigInt</span><span class="c2">(</span><span class="c0">9007199254740991</span><span class="c2 c3">)</span></p><p class="c1"><span class="c5 c3">// &#8618; 9007199254740991n</span></p><p class="c1"><span class="c2">&nbsp; </span><span class="c5 c3">/* Symbol - It is a new data type introduced in the ES6 version of javascript.It is used to store an anonymous and unique value.</span></p><p class="c1"><span class="c5 c3">&nbsp; Example : */</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c6">var</span><span class="c2">&nbsp;symbol1 </span><span class="c6">=</span><span class="c2">&nbsp;</span><span class="c0">Symbol</span><span class="c2">(</span><span class="c7">&#39;symbol&#39;</span><span class="c2 c3">);</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">/* By specification, object property keys may be either of string type, or of symbol type.Not numbers, not booleans, only strings or symbols, these two types. A &ldquo;symbol&rdquo; represents a unique identifier. A value of this type can be created using Symbol(): */</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c6">let</span><span class="c2">&nbsp;id </span><span class="c6">=</span><span class="c2">&nbsp;</span><span class="c0">Symbol</span><span class="c2 c3">();</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">/* Upon creation, we can give symbol a description(also called a symbol name), mostly useful for debugging purposes: */</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c6">let</span><span class="c2">&nbsp;id </span><span class="c6">=</span><span class="c2">&nbsp;</span><span class="c0">Symbol</span><span class="c2">(</span><span class="c7">&quot;id&quot;</span><span class="c2 c3">);</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">/* Symbols are guaranteed to be unique.Even if we create many symbols with the same description, they are different values.The description is just a label that doesn&rsquo;t affect anything. Most values in JavaScript support implicit conversion to a string.For instance, we can alert almost any value, and it will work.Symbols are special. They don&rsquo;t auto - convert. Any data type that is not a primitive data type, is of Object type in javascript.*/</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">//HOISTING</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">/*Hoisting is the default behavior of javascript where all the variable and function declarations are moved on top. This means that irrespective of where the variables and functions are declared, they are moved on top of the scope.The scope can be both local and global. Variable initializations are not hoisted, only variable declarations are hoisted. To avoid hoisting, you can run javascript in strict mode by using &ldquo;use strict&rdquo; on top of the code: */</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c7">&quot;use strict&quot;</span><span class="c2 c3">;</span></p><p class="c1"><span class="c2">&nbsp;x </span><span class="c6">=</span><span class="c2">&nbsp;</span><span class="c0">23</span><span class="c2">; </span><span class="c5 c3">// Gives an error since &#39;x&#39; is not declared</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c6">var</span><span class="c2 c3">&nbsp;x;</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">//STRING MANIPULATION</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">/* In addition of 2 variables, say a and b if both are numbers only then actual addition (numeric) occurs. If both or any one of them are strings, then string concatenation occurs. In subtraction of two vars, actual subtraction as of numbers is done regardless of whether either of a and b are string or numbers. In case if either or both of a, b is bool then actual addition / subtraction takes place considering its value as 1 / 0.*/</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">//COERCION</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">/*Truthy values are those which will be converted(coerced) to true. Falsy values are those which will be converted to false. All values except 0, 0n, -0, &ldquo;&rdquo;, null, undefined and NaN are truthy values. While using the &lsquo;==&rsquo; operator, coercion takes place. The &lsquo;==&rsquo; operator, converts both the operands to the same type and then compares them.</span></p><p class="c1"><span class="c5 c3">&nbsp;Example: */</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c6">var</span><span class="c2">&nbsp;a </span><span class="c6">=</span><span class="c2">&nbsp;</span><span class="c0">12</span><span class="c2 c3">;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c6">var</span><span class="c2">&nbsp;b </span><span class="c6">=</span><span class="c2">&nbsp;</span><span class="c7">&quot;12&quot;</span><span class="c2 c3">;</span></p><p class="c1"><span class="c2">&nbsp;a </span><span class="c6">==</span><span class="c2">&nbsp;b </span><span class="c5 c3">// Returns true</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">//NAN</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">/* NaN property represents &ldquo;Not - a - Number&rdquo; value.It indicates a value which is not a legal number. typeof of a NaN will return a Number. To check if a value is NaN, we use the isNaN() function. isNaN() function converts the given value to a Number type, and then equates to NaN. */</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c0">isNaN</span><span class="c2">(</span><span class="c7">&quot;Hello&quot;</span><span class="c2">) &nbsp;</span><span class="c5 c3">// Returns true</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c0">isNaN</span><span class="c2">(</span><span class="c0">345</span><span class="c2">) &nbsp; </span><span class="c5 c3">// Returns false</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c0">isNaN</span><span class="c2">(</span><span class="c7">&#39;1&#39;</span><span class="c2">) &nbsp;</span><span class="c5 c3">// Returns false, since &#39;1&#39; is converted to Number type which results in 0 ( a number)</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c0">isNaN</span><span class="c2">(</span><span class="c0">true</span><span class="c2">) </span><span class="c5 c3">// Returns false, since true converted to Number type results in 1 ( a number)</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c0">isNaN</span><span class="c2">(</span><span class="c0">false</span><span class="c2">) </span><span class="c5 c3">// Returns false</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c0">isNaN</span><span class="c2">(</span><span class="c0">undefined</span><span class="c2">) </span><span class="c5 c3">// Returns true</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; </span><span class="c5 c3">//PASSING BY REFERENCE</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; </span><span class="c5 c3">/* Suppose a is an argument passed to a function. If a is primitive, then a copy of &#39;a&#39; is received. While on the other hand if a is non primitive in nature, a reference to is received. But if the function is&lsquo;nt tweaking the internal components(obj prop, array element) of the non primitive argument a, but rather altering the arg or its value itself(reassigning etc) then the reference is neglected and the the arg is treated as a copy. Other than passing parameters to functions, same is the case with assigning variables. */</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; </span><span class="c5 c3">//IMMDIATELY INVOKED FUNCTIONS</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; </span><span class="c5 c3">/*An Immediately Invoked Function is a function that runs as soon as it is defined. Syntax of IIFE: */</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; (</span><span class="c6">function</span><span class="c2 c3">&nbsp;() {</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; console.</span><span class="c4">log</span><span class="c2">(</span><span class="c7">&#39;kk&#39;</span><span class="c2 c3">);</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; })(); </span><span class="c5 c3">//prints kk</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">//HIGHER ORDER FUNCTIONS</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">/* Functions that operate on other functions, either by taking them as arguments or by returning them, are called higher - order functions. Higher order functions are a result of functions being first - class citizens in javascript. Examples of higher order functions: */</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c6">function</span><span class="c2">&nbsp;</span><span class="c4">higherOrder</span><span class="c2">(</span><span class="c8">fn</span><span class="c2 c3">) {</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; </span><span class="c4">fn</span><span class="c2 c3">();</span></p><p class="c1"><span class="c2 c3">&nbsp;}</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c4">higherOrder</span><span class="c2">(</span><span class="c6">function</span><span class="c2">&nbsp;() { console.</span><span class="c4">log</span><span class="c2">(</span><span class="c7">&quot;Hello world&quot;</span><span class="c2 c3">) });</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c6">function</span><span class="c2">&nbsp;</span><span class="c4">higherOrder2</span><span class="c2 c3">() {</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; </span><span class="c6">return</span><span class="c2">&nbsp;</span><span class="c6">function</span><span class="c2 c3">&nbsp;() {</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6">return</span><span class="c2">&nbsp;</span><span class="c7">&quot;Do something&quot;</span><span class="c2 c3">;</span></p><p class="c1"><span class="c2 c3">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c2 c3">&nbsp;}</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c6">var</span><span class="c2">&nbsp;x </span><span class="c6">=</span><span class="c2">&nbsp;</span><span class="c4">higherOrder2</span><span class="c2 c3">();</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c4">x</span><span class="c2">() &nbsp; </span><span class="c5 c3">// Returns &quot;Do something&quot;</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">//THIS</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c5 c3">/* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this */</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">//FUNCTION FUNCTIONS</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">/* The bind() method creates a new function that, when called, has its this keyword refer to the provided object, with a given sequence of arguments preceding the obj when the new function is called. The bind func works only once. Calling bind() on a func that is itself a return of bind() is allowed but doesn&#39;t work. The this of the func under concern will still refer to the scope it was originally binded to. Also, bind, call and apply do not work if the function is declared using arrow operator. */</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c6">const</span><span class="c2">&nbsp;</span><span class="c0">module</span><span class="c2">&nbsp;</span><span class="c6">=</span><span class="c2 c3">&nbsp;{</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; x: </span><span class="c0">42</span><span class="c2 c3">,</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; </span><span class="c4">getX</span><span class="c2">: </span><span class="c6">function</span><span class="c2 c3">&nbsp;() {</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6">return</span><span class="c2">&nbsp;</span><span class="c0">this</span><span class="c2 c3">.x;</span></p><p class="c1"><span class="c2 c3">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c2 c3">&nbsp;};</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c6">const</span><span class="c2">&nbsp;</span><span class="c0">unboundGetX</span><span class="c2">&nbsp;</span><span class="c6">=</span><span class="c2">&nbsp;</span><span class="c0">module</span><span class="c2 c3">.getX;</span></p><p class="c1"><span class="c2">&nbsp;console.</span><span class="c4">log</span><span class="c2">(</span><span class="c4">unboundGetX</span><span class="c2">()); </span><span class="c5 c3">// The function gets invoked at the global scope</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">// expected output: undefined</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c6">const</span><span class="c2">&nbsp;</span><span class="c0">boundGetX</span><span class="c2">&nbsp;</span><span class="c6">=</span><span class="c2">&nbsp;unboundGetX.</span><span class="c4">bind</span><span class="c2">(</span><span class="c0">module</span><span class="c2 c3">);</span></p><p class="c1"><span class="c2">&nbsp;console.</span><span class="c4">log</span><span class="c2">(</span><span class="c4">boundGetX</span><span class="c2 c3">());</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">// expected output: 42</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c6">let</span><span class="c2">&nbsp;o </span><span class="c6">=</span><span class="c2 c3">&nbsp;{</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; a: </span><span class="c7">&#39;a&#39;</span><span class="c2 c3">,</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; </span><span class="c4">b</span><span class="c2">: </span><span class="c6">function</span><span class="c2 c3">&nbsp;() {</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; console.</span><span class="c4">log</span><span class="c2">(</span><span class="c0">this</span><span class="c2 c3">.a);</span></p><p class="c1"><span class="c2 c3">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c2 c3">&nbsp;};</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c6">function</span><span class="c2">&nbsp;</span><span class="c4">f</span><span class="c2">(</span><span class="c8">c</span><span class="c2">) { </span><span class="c4">c</span><span class="c2 c3">(); };</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c6">let</span><span class="c2">&nbsp;tmp </span><span class="c6">=</span><span class="c2 c3">&nbsp;o.b;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c4">tmp</span><span class="c2">();</span><span class="c5 c3">//undefined</span></p><p class="c1"><span class="c2">&nbsp;tmp </span><span class="c6">=</span><span class="c2">&nbsp;tmp.</span><span class="c4">bind</span><span class="c2 c3">(o);</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c4">tmp</span><span class="c2">();</span><span class="c5 c3">//&#39;a&#39;</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">/* obj is the scope of &#39;this&#39; in function binded to. */</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c6">let</span><span class="c2">&nbsp;obj </span><span class="c6">=</span><span class="c2 c3">&nbsp;{</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; name: </span><span class="c7 c3">&#39;johnny&#39;</span></p><p class="c1"><span class="c2 c3">&nbsp;}</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">//call</span></p><p class="c1"><span class="c2">&nbsp;func.</span><span class="c4">call</span><span class="c2">(obj, </span><span class="c7">&#39;straight&#39;</span><span class="c2 c3">)</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">//apply takes in an array of args rather than many args and maps &#39;em with parameters</span></p><p class="c1"><span class="c2">&nbsp;func.</span><span class="c4">apply</span><span class="c2">(obj, [</span><span class="c7">&#39;gay&#39;</span><span class="c2 c3">]);</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">//bind returns a func which when called will actually call the original function</span></p><p class="c1"><span class="c2">&nbsp;(func.</span><span class="c4">bind</span><span class="c2">(obj, </span><span class="c7">&#39;asexual&#39;</span><span class="c2 c3">))();</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c3 c5">//CURRYING</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">/* Currying is an advanced technique to transform a function of arguments n, to n functions of one or less arguments. Example of a curried function: */</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c6">function</span><span class="c2">&nbsp;</span><span class="c4">add</span><span class="c2">(</span><span class="c8">a</span><span class="c2 c3">) {</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; </span><span class="c6">return</span><span class="c2">&nbsp;</span><span class="c6">function</span><span class="c2">&nbsp;(</span><span class="c8">b</span><span class="c2 c3">) {</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6">return</span><span class="c2">&nbsp;a </span><span class="c6">+</span><span class="c2 c3">&nbsp;b;</span></p><p class="c1"><span class="c2 c3">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c2 c3">&nbsp;}</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c4">add</span><span class="c2">(</span><span class="c0">3</span><span class="c2">)(</span><span class="c0">4</span><span class="c2 c3">)</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">/* For Example, if we have a function f(a, b) , then the function after currying, will be transformed to f(a)(b). By using the currying technique, we do not change the functionality of a function, we just change the way it is invoked. Let&rsquo;s see currying in action: */</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c6">function</span><span class="c2">&nbsp;</span><span class="c4">multiply</span><span class="c2">(</span><span class="c8">a</span><span class="c2">, </span><span class="c8">b</span><span class="c2 c3">) {</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; </span><span class="c6">return</span><span class="c2">&nbsp;a </span><span class="c6">*</span><span class="c2 c3">&nbsp;b;</span></p><p class="c1"><span class="c2 c3">&nbsp;}</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c6">function</span><span class="c2">&nbsp;</span><span class="c4">currying</span><span class="c2">(</span><span class="c8">fn</span><span class="c2 c3">) {</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; </span><span class="c6">return</span><span class="c2">&nbsp;</span><span class="c6">function</span><span class="c2">&nbsp;(</span><span class="c8">a</span><span class="c2 c3">) {</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6">return</span><span class="c2">&nbsp;</span><span class="c6">function</span><span class="c2">&nbsp;(</span><span class="c8">b</span><span class="c2 c3">) {</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6">return</span><span class="c2">&nbsp;</span><span class="c4">fn</span><span class="c2">(</span><span class="c8">a</span><span class="c2">, </span><span class="c8">b</span><span class="c2 c3">);</span></p><p class="c1"><span class="c2 c3">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c2 c3">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c2 c3">&nbsp;}</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c6">var</span><span class="c2">&nbsp;</span><span class="c4">curriedMultiply</span><span class="c2">&nbsp;</span><span class="c6">=</span><span class="c2">&nbsp;</span><span class="c4">currying</span><span class="c2">(</span><span class="c4">multiply</span><span class="c2 c3">);</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c4">multiply</span><span class="c2">(</span><span class="c0">4</span><span class="c2">, </span><span class="c0">3</span><span class="c2">); </span><span class="c5 c3">// Returns 12</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c4">curriedMultiply</span><span class="c2">(</span><span class="c0">4</span><span class="c2">)(</span><span class="c0">3</span><span class="c2">); </span><span class="c5 c3">// Also returns 12</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">/* As one can see in the code above, we have transformed the function multiply(a, b) to a function curriedMultiply , which takes in one parameter at a time. */</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">//COSURE</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c6">let</span><span class="c2">&nbsp;</span><span class="c4">x</span><span class="c2">&nbsp;</span><span class="c6">=</span><span class="c2">&nbsp;() </span><span class="c6">=&gt;</span><span class="c2 c3">&nbsp;{</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; </span><span class="c6">let</span><span class="c2">&nbsp;y </span><span class="c6">=</span><span class="c2">&nbsp;</span><span class="c7">&#39;4&#39;</span><span class="c2 c3">;</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; </span><span class="c6">return</span><span class="c2">&nbsp;() </span><span class="c6">=&gt;</span><span class="c2 c3">&nbsp;{</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">console</span><span class="c2">.</span><span class="c4">log</span><span class="c2 c3">(y);</span></p><p class="c1"><span class="c2 c3">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c2 c3">&nbsp;}</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c4">x</span><span class="c2 c3">()();</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">/* Closure is a prop of js by virtue of which a reference to the lexical scope of a function is attached to it when the func is defined. This scope consists of all the variables required by the func and not defined within it&#39;s own scope.</span></p><p class="c1"><span class="c5 c3">&nbsp; &nbsp;x(), instead of destroying the value of y after execution, saves the value in the memory for further reference. This is the reason why the returning function is able to use the variable declared in the outer scope even after the function is already executed. */</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">//PROTOTYPE</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">/* https://javascript.info/prototypes</span></p><p class="c1"><span class="c5 c3">&nbsp;suppose an obj o={a:&#39;a&#39;,f:function(){return this.a},g:function(){this.a=&#39;A&#39;}}</span></p><p class="c1"><span class="c5 c3">another obj m={...somePropOwn,__proto__:o}</span></p><p class="c1"><span class="c5 c3">Calling a getter func such as f on m will return parent&#39;s value of key found through protypical inheritance, ie val of a from o. But calling a setter func such as g on m will have &#39;this&#39; binded to child obj and thus affects contents of its own and not of the parent/prototype. */</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c6">let</span><span class="c2">&nbsp;arr </span><span class="c6">=</span><span class="c2">&nbsp;[</span><span class="c0">4</span><span class="c2">, </span><span class="c7">&#39;h&#39;</span><span class="c2 c3">];</span></p><p class="c1"><span class="c2">&nbsp;arr.</span><span class="c4">push</span><span class="c2">(</span><span class="c0">false</span><span class="c2 c3">);</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">/* Object has a property(obj) - prototype. Any obj that we create(array, js obj, etc) inherits all the properties from this global Object&#39;s property, prototype obj. But this obj that we create also has a protype of its own, possibly containing props. We can add to the props of this proto. So when we access a property on an obj which possibly we created no failure is resulted unless this prop that we access is neither present in the obj&#39;s proto (or any of the protos that this obj inherits from) nor have we defined it ourselves in the obj. For example, the push on arr works because even though no such function has been defined by us, but its present in the proto of Array obj. */</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">//ARROW</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">/* By general definition, the this keyword always refers to the object that is calling the function. In the arrow functions, there is no binding of the this keyword. The this keyword inside an arrow function, does not refer to the object calling it. It rather inherits its value from the parent scope. */</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">//REST AND SPREAD</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">/* Rest provides an improved way of handling parameters of a function. Using the rest parameter syntax, we can create functions that can take a variable number of arguments. Any number of arguments will be converted into an array using the rest parameter. It also helps in extracting all or some parts of the arguments. Rest parameter can be used by applying three dots (...) before the parameters. */</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c6">function</span><span class="c2">&nbsp;</span><span class="c4">extractingArgs</span><span class="c2">(</span><span class="c6">...</span><span class="c8">args</span><span class="c2 c3">) {</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; </span><span class="c6">return</span><span class="c2">&nbsp;</span><span class="c8">args</span><span class="c2">[</span><span class="c0">1</span><span class="c2 c3">];</span></p><p class="c1"><span class="c2 c3">&nbsp;}</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">// extractingArgs(8,9,1); // Returns 9</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c6">function</span><span class="c2">&nbsp;</span><span class="c4">addAllArgs</span><span class="c2">(</span><span class="c6">...</span><span class="c8">args</span><span class="c2 c3">) {</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; </span><span class="c6">let</span><span class="c2">&nbsp;sumOfArgs </span><span class="c6">=</span><span class="c2">&nbsp;</span><span class="c0">0</span><span class="c2 c3">;</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; </span><span class="c6">let</span><span class="c2">&nbsp;i </span><span class="c6">=</span><span class="c2">&nbsp;</span><span class="c0">0</span><span class="c2 c3">;</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; </span><span class="c6">while</span><span class="c2">&nbsp;(i </span><span class="c6">&lt;</span><span class="c2">&nbsp;</span><span class="c8">args</span><span class="c2">.</span><span class="c0">length</span><span class="c2 c3">) {</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; sumOfArgs </span><span class="c6">+=</span><span class="c2">&nbsp;</span><span class="c8">args</span><span class="c2 c3">[i];</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; i</span><span class="c6">++</span><span class="c2 c3">;</span></p><p class="c1"><span class="c2 c3">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; </span><span class="c6">return</span><span class="c2 c3">&nbsp;sumOfArgs;</span></p><p class="c1"><span class="c2 c3">&nbsp;}</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c4">addAllArgs</span><span class="c2">(</span><span class="c0">6</span><span class="c2">, </span><span class="c0">5</span><span class="c2">, </span><span class="c0">7</span><span class="c2">, </span><span class="c0">99</span><span class="c2">); </span><span class="c5 c3">// Returns 117</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c4">addAllArgs</span><span class="c2">(</span><span class="c0">1</span><span class="c2">, </span><span class="c0">3</span><span class="c2">, </span><span class="c0">4</span><span class="c2">); </span><span class="c5 c3">// Returns 8</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">// Rest parameter should always be used at the last parameter of a function:</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">// Incorrect way to use rest parameter</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c6">function</span><span class="c2">&nbsp;</span><span class="c4">randomFunc</span><span class="c2">(</span><span class="c8">a</span><span class="c2">, </span><span class="c6">...</span><span class="c8">args</span><span class="c2">, </span><span class="c8">c</span><span class="c2 c3">) {</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; </span><span class="c5 c3">//Do something</span></p><p class="c1"><span class="c2 c3">&nbsp;}</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">// Correct way to use rest parameter</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c6">function</span><span class="c2">&nbsp;</span><span class="c4">randomFunc2</span><span class="c2">(</span><span class="c8">a</span><span class="c2">, </span><span class="c8">b</span><span class="c2">, </span><span class="c6">...</span><span class="c8">args</span><span class="c2 c3">) {</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; </span><span class="c5 c3">//Do something</span></p><p class="c1"><span class="c2 c3">&nbsp;}</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">//GENERATOR`</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">/* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator */</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">//CLASS</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">/* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes */</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">//Object destructuring:</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c6">const</span><span class="c2">&nbsp;</span><span class="c0">classDetails</span><span class="c2">&nbsp;</span><span class="c6">=</span><span class="c2 c3">&nbsp;{</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; strength: </span><span class="c0">78</span><span class="c2 c3">,</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; benches: </span><span class="c0">39</span><span class="c2 c3">,</span></p><p class="c1"><span class="c2">&nbsp; &nbsp; blackBoard: </span><span class="c0 c3">1</span></p><p class="c1"><span class="c2 c3">&nbsp;}</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c6">const</span><span class="c2">&nbsp;{ strength: </span><span class="c0">classStrength</span><span class="c2">, benches: </span><span class="c0">classBenches</span><span class="c2">, blackBoard: </span><span class="c0">classBlackBoard</span><span class="c2">&nbsp;} </span><span class="c6">=</span><span class="c2">&nbsp;</span><span class="c0">classDetails</span><span class="c2 c3">;</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c0">console</span><span class="c2">.</span><span class="c4">log</span><span class="c2">(</span><span class="c0">classStrength</span><span class="c2">); </span><span class="c5 c3">// Outputs 78</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c0">console</span><span class="c2">.</span><span class="c4">log</span><span class="c2">(</span><span class="c0">classBenches</span><span class="c2">); </span><span class="c5 c3">// Outputs 39</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c0">console</span><span class="c2">.</span><span class="c4">log</span><span class="c2">(</span><span class="c0">classBlackBoard</span><span class="c2">); </span><span class="c5 c3">// Outputs 1</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">/* As one can see, using object destructuring we have extracted all the elements inside an object in one line of code. If we want our new variable to have the same name as the property of an object we can remove the colon: */</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c6">const</span><span class="c2">&nbsp;{ strength: </span><span class="c0">strength</span><span class="c2">&nbsp;} </span><span class="c6">=</span><span class="c2">&nbsp;</span><span class="c0">classDetails</span><span class="c2 c3">;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">// The above line of code can be written as:</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c6">const</span><span class="c2">&nbsp;{ </span><span class="c0">strength</span><span class="c2">&nbsp;} </span><span class="c6">=</span><span class="c2">&nbsp;</span><span class="c0">classDetails</span><span class="c2 c3">;</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">//Array destructuring:</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">/* The same example using object destructuring: */</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c6">const</span><span class="c2">&nbsp;</span><span class="c0">arr</span><span class="c2">&nbsp;</span><span class="c6">=</span><span class="c2">&nbsp;[</span><span class="c0">1</span><span class="c2">, </span><span class="c0">2</span><span class="c2">, </span><span class="c0">3</span><span class="c2">, </span><span class="c0">4</span><span class="c2 c3">];</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c6">const</span><span class="c2">&nbsp;[</span><span class="c0">first</span><span class="c2">, </span><span class="c0">second</span><span class="c2">, </span><span class="c0">third</span><span class="c2">, </span><span class="c0">fourth</span><span class="c2">] </span><span class="c6">=</span><span class="c2 c3">&nbsp;arr;</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c0">console</span><span class="c2">.</span><span class="c4">log</span><span class="c2">(</span><span class="c0">first</span><span class="c2">); </span><span class="c5 c3">// Outputs 1</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c0">console</span><span class="c2">.</span><span class="c4">log</span><span class="c2">(</span><span class="c0">second</span><span class="c2">); </span><span class="c5 c3">// Outputs 2</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">//TEMPORAL DEAD ZONE</span></p><p class="c1"><span class="c2 c3">&nbsp;</span></p><p class="c1"><span class="c2">&nbsp;</span><span class="c5 c3">/* Temporal Dead Zone is a behaviour that occurs with variables declared using let and const keywords.</span></p><p class="c1"><span class="c5 c3">&nbsp;</span></p><p class="c1"><span class="c5 c3">&nbsp;It is a behaviour where we try to access a variable before it is initialized. */</span></p></body></html>