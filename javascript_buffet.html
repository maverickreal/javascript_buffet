<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c2{background-color:#24292e;padding-top:0pt;padding-bottom:0pt;line-height:1.35;orphans:2;widows:2;text-align:left}.c4{color:#6a737d;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:15pt;font-family:"Courier New";font-style:normal}.c3{color:#e1e4e8;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:15pt;font-family:"Courier New";font-style:normal}.c0{font-size:15pt;font-family:"Courier New";color:#79b8ff;font-weight:400}.c5{font-size:15pt;font-family:"Courier New";color:#b392f0;font-weight:400}.c1{font-size:15pt;font-family:"Courier New";color:#f97583;font-weight:400}.c9{font-size:15pt;font-family:"Courier New";color:#ffab70;font-weight:400}.c7{font-size:15pt;font-family:"Courier New";color:#e1e4e8;font-weight:400}.c8{font-size:15pt;font-family:"Courier New";color:#9ecbff;font-weight:400}.c11{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c10{text-decoration:none;vertical-align:baseline;font-style:normal}.c6{height:11pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c11"><p class="c2"><span class="c4">//SPECIAL DATA TYPES</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">/* BigInt - This data type is used to store numbers which are above the limitation of the Number data type.It can store large integers and is represented by adding &ldquo;n&rdquo; to an integer literal.</span></p><p class="c2"><span class="c4">&nbsp;Example : */</span></p><p class="c2"><span class="c1">var</span><span class="c7">&nbsp;bigInteger </span><span class="c1">=</span><span class="c7">&nbsp;</span><span class="c0">234567890123456789012345678901234567890</span><span class="c3">;</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">/* Symbol - It is a new data type introduced in the ES6 version of javascript.It is used to store an anonymous and unique value.</span></p><p class="c2"><span class="c4">&nbsp;Example : */</span></p><p class="c2"><span class="c1">var</span><span class="c7">&nbsp;symbol1 </span><span class="c1">=</span><span class="c7">&nbsp;</span><span class="c0">Symbol</span><span class="c7">(</span><span class="c8">&#39;symbol&#39;</span><span class="c3">);</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">/* By specification, object property keys may be either of string type, or of symbol type.Not numbers, not booleans, only strings or symbols, these two types. A &ldquo;symbol&rdquo; represents a unique identifier. A value of this type can be created using Symbol(): */</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c1">let</span><span class="c7">&nbsp;id </span><span class="c1">=</span><span class="c7">&nbsp;</span><span class="c0">Symbol</span><span class="c3">();</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">//Upon creation, we can give symbol a description(also called a symbol name), mostly useful for debugging purposes:</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c1">let</span><span class="c7">&nbsp;id </span><span class="c1">=</span><span class="c7">&nbsp;</span><span class="c0">Symbol</span><span class="c7">(</span><span class="c8">&quot;id&quot;</span><span class="c3">);</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">/* Symbols are guaranteed to be unique.Even if we create many symbols with the same description, they are different values.The description is just a label that doesn&rsquo;t affect anything. Most values in JavaScript support implicit conversion to a string.For instance, we can alert almost any value, and it will work.Symbols are special.They don&rsquo;t auto - convert. Any data type that is not a primitive data type, is of Object type in javascript.*/</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">//HOISTING</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">/*Hoisting is the default behavior of javascript where all the variable and function declarations are moved on top. This means that irrespective of where the variables and functions are declared, they are moved on top of the scope.The scope can be both local and global.ariable initializations are not hoisted, only variable declarations are hoisted. To avoid hoisting, you can run javascript in strict mode by using &ldquo;use strict&rdquo; on top of the code: */</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c8">&quot;use strict&quot;</span><span class="c3">;</span></p><p class="c2"><span class="c7">x </span><span class="c1">=</span><span class="c7">&nbsp;</span><span class="c0">23</span><span class="c7">; </span><span class="c4">// Gives an error since &#39;x&#39; is not declared</span></p><p class="c2"><span class="c1">var</span><span class="c3">&nbsp;x;</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">//STRING MANIPULATION</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">/* In addition of 2 variables, say a and b if both are numbers only then all actual addition occurs.If both or any one of them are strings, then string concatenation occurs. In subtraction of two vars, actual subtraction as of numbers is done regardless of whether either of a and b are string or numbers. In case if either or both of a, b is bool then actual addition / subtraction takes place considering its value as 1 / 0.*/</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">//COERCION</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">/*Truthy values are those which will be converted(coerced) to true.Falsy values are those which will be converted to false. All values except 0, 0n, -0, &ldquo;&rdquo;, null, undefined and NaN are truthy values. While using the &lsquo;==&rsquo; operator, coercion takes place. The &lsquo;==&rsquo; operator, converts both the operands to the same type and then compares them.</span></p><p class="c2"><span class="c4">Example: */</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c1">var</span><span class="c7">&nbsp;a </span><span class="c1">=</span><span class="c7">&nbsp;</span><span class="c0">12</span><span class="c3">;</span></p><p class="c2"><span class="c1">var</span><span class="c7">&nbsp;b </span><span class="c1">=</span><span class="c7">&nbsp;</span><span class="c8">&quot;12&quot;</span><span class="c3">;</span></p><p class="c2"><span class="c7">a </span><span class="c1">==</span><span class="c7">&nbsp;b </span><span class="c4">// Returns true</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">//NAN</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">/* NaN property represents &ldquo;Not - a - Number&rdquo; value.It indicates a value which is not a legal number. typeof of a NaN will return a Number. To check if a value is NaN, we use the isNaN() function. isNaN() function converts the given value to a Number type, and then equates to NaN. */</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c0">isNaN</span><span class="c7">(</span><span class="c8">&quot;Hello&quot;</span><span class="c7">) &nbsp;</span><span class="c4">// Returns true</span></p><p class="c2"><span class="c0">isNaN</span><span class="c7">(</span><span class="c0">345</span><span class="c7">) &nbsp; </span><span class="c4">// Returns false</span></p><p class="c2"><span class="c0">isNaN</span><span class="c7">(</span><span class="c8">&#39;1&#39;</span><span class="c7">) &nbsp;</span><span class="c4">// Returns false, since &#39;1&#39; is converted to Number type which results in 0 ( a number)</span></p><p class="c2"><span class="c0">isNaN</span><span class="c7">(</span><span class="c0">true</span><span class="c7">) </span><span class="c4">// Returns false, since true converted to Number type results in 1 ( a number)</span></p><p class="c2"><span class="c0">isNaN</span><span class="c7">(</span><span class="c0">false</span><span class="c7">) </span><span class="c4">// Returns false</span></p><p class="c2"><span class="c0">isNaN</span><span class="c7">(</span><span class="c0">undefined</span><span class="c7">) </span><span class="c4">// Returns true</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c7">&nbsp; &nbsp;</span><span class="c4">//PASSING BY REFERENCE</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c7">&nbsp; &nbsp;</span><span class="c4">/* Suppose a is an argument passed to a function. If a is primitive, the a copy of a is received.While on the other hand if a is non primitive in nature, a reference to is received.But if the function is&lsquo;nt tweaking the internal components(obj prop, array elemen) of the non primitive argument a, but rather altering the arg or its value itself(reassigning etc) then the reference is neglected and the the arg is treated as a copy.Other than passing parameters to functions, same is the case with assigning variables. */</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c7">&nbsp; &nbsp;</span><span class="c4">//IMMDIATELY INVOKED FUNCTIONS</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c7">&nbsp; &nbsp;</span><span class="c4">/*An Immediately Invoked Function is a function that runs as soon as it is defined. Syntax of IIFE: */</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c7">&nbsp; &nbsp;(</span><span class="c1">function</span><span class="c3">&nbsp;() {</span></p><p class="c2"><span class="c7">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">console</span><span class="c7">.</span><span class="c5">log</span><span class="c7">(</span><span class="c8">&#39;kk&#39;</span><span class="c3">);</span></p><p class="c2"><span class="c7">&nbsp; &nbsp;})(); </span><span class="c4">//prints kk</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">//HIGHER ORDER FUNCTIONS</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">/* Functions that operate on other functions, either by taking them as arguments or by returning them, are called higher - order functions. Higher order functions are a result of functions being first - class citizens in javascript. Examples of higher order functions: */</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c1">function</span><span class="c7">&nbsp;</span><span class="c5">higherOrder</span><span class="c7">(</span><span class="c9">fn</span><span class="c3">) {</span></p><p class="c2"><span class="c7">&nbsp; &nbsp;</span><span class="c5">fn</span><span class="c3">();</span></p><p class="c2"><span class="c3">}</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c5">higherOrder</span><span class="c7">(</span><span class="c1">function</span><span class="c7">&nbsp;() { </span><span class="c0">console</span><span class="c7">.</span><span class="c5">log</span><span class="c7">(</span><span class="c8">&quot;Hello world&quot;</span><span class="c3">) });</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c1">function</span><span class="c7">&nbsp;</span><span class="c5">higherOrder2</span><span class="c3">() {</span></p><p class="c2"><span class="c7">&nbsp; &nbsp;</span><span class="c1">return</span><span class="c7">&nbsp;</span><span class="c1">function</span><span class="c3">&nbsp;() {</span></p><p class="c2"><span class="c7">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1">return</span><span class="c7">&nbsp;</span><span class="c8">&quot;Do something&quot;</span><span class="c3">;</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;}</span></p><p class="c2"><span class="c3">}</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c1">var</span><span class="c7">&nbsp;x </span><span class="c1">=</span><span class="c7">&nbsp;</span><span class="c5">higherOrder2</span><span class="c3">();</span></p><p class="c2"><span class="c5">x</span><span class="c7">() &nbsp; </span><span class="c4">// Returns &quot;Do something&quot;</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">//THIS</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c1">function</span><span class="c7">&nbsp;</span><span class="c5">func</span><span class="c7">(</span><span class="c9">message</span><span class="c3">) {</span></p><p class="c2"><span class="c7">&nbsp; &nbsp;</span><span class="c0">console</span><span class="c7">.</span><span class="c5">log</span><span class="c7">(</span><span class="c0">this</span><span class="c7">.name </span><span class="c1">+</span><span class="c7">&nbsp;</span><span class="c8">&quot; is &quot;</span><span class="c7">&nbsp;</span><span class="c1">+</span><span class="c7">&nbsp;</span><span class="c9">message</span><span class="c3">);</span></p><p class="c2"><span class="c3">}</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">//FUNCTION FUNCTIONS</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">/* The bind() method creates a new function that, when called, has its this keyword set to the provided value, with a given sequence of arguments preceding any provided when the new function is called. */</span></p><p class="c2"><span class="c1">const</span><span class="c7">&nbsp;</span><span class="c0">module</span><span class="c7">&nbsp;</span><span class="c1">=</span><span class="c3">&nbsp;{</span></p><p class="c2"><span class="c7">&nbsp; &nbsp;x: </span><span class="c0">42</span><span class="c3">,</span></p><p class="c2"><span class="c7">&nbsp; &nbsp;</span><span class="c5">getX</span><span class="c7">: </span><span class="c1">function</span><span class="c3">&nbsp;() {</span></p><p class="c2"><span class="c7">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1">return</span><span class="c7">&nbsp;</span><span class="c0">this</span><span class="c3">.x;</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;}</span></p><p class="c2"><span class="c3">};</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c1">const</span><span class="c7">&nbsp;</span><span class="c5">unboundGetX</span><span class="c7">&nbsp;</span><span class="c1">=</span><span class="c7">&nbsp;</span><span class="c0">module</span><span class="c7">.</span><span class="c5">getX</span><span class="c3">;</span></p><p class="c2"><span class="c0">console</span><span class="c7">.</span><span class="c5">log</span><span class="c7">(</span><span class="c5">unboundGetX</span><span class="c7">()); </span><span class="c4">// The function gets invoked at the global scope</span></p><p class="c2"><span class="c4">// expected output: undefined</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c1">const</span><span class="c7">&nbsp;</span><span class="c0">boundGetX</span><span class="c7">&nbsp;</span><span class="c1">=</span><span class="c7">&nbsp;</span><span class="c5">unboundGetX</span><span class="c7">.</span><span class="c5">bind</span><span class="c7">(</span><span class="c0">module</span><span class="c3">);</span></p><p class="c2"><span class="c0">console</span><span class="c7">.</span><span class="c5">log</span><span class="c7">(</span><span class="c5">boundGetX</span><span class="c3">());</span></p><p class="c2"><span class="c4">// expected output: 42</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c1">let</span><span class="c7">&nbsp;o </span><span class="c1">=</span><span class="c3">&nbsp;{</span></p><p class="c2"><span class="c7">&nbsp; &nbsp;a: </span><span class="c8">&#39;a&#39;</span><span class="c3">,</span></p><p class="c2"><span class="c7">&nbsp; &nbsp;</span><span class="c5">b</span><span class="c7">: </span><span class="c1">function</span><span class="c3">&nbsp;() {</span></p><p class="c2"><span class="c7">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">console</span><span class="c7">.</span><span class="c5">log</span><span class="c7">(</span><span class="c0">this</span><span class="c3">.a);</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;}</span></p><p class="c2"><span class="c3">};</span></p><p class="c2"><span class="c1">function</span><span class="c7">&nbsp;</span><span class="c5">f</span><span class="c7">(</span><span class="c9">c</span><span class="c7">) { </span><span class="c5">c</span><span class="c3">(); };</span></p><p class="c2"><span class="c1">let</span><span class="c7">&nbsp;</span><span class="c5">tmp</span><span class="c7">&nbsp;</span><span class="c1">=</span><span class="c7">&nbsp;o.</span><span class="c5">b</span><span class="c3">;</span></p><p class="c2"><span class="c5">tmp</span><span class="c7">();</span><span class="c4">//undefined</span></p><p class="c2"><span class="c5">tmp</span><span class="c7">&nbsp;</span><span class="c1">=</span><span class="c7">&nbsp;</span><span class="c5">tmp</span><span class="c7">.</span><span class="c5">bind</span><span class="c3">(o);</span></p><p class="c2"><span class="c5">tmp</span><span class="c7">();</span><span class="c4">//&#39;a&#39;</span></p><p class="c2"><span class="c4">//The bind() method creates a new function that, when called, has its this keyword set to the provided value, with a given sequence of arguments preceding any provided when the new function is called.</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">/* obj is the scope of &#39;this&#39; in function binded to. */</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c1">let</span><span class="c7">&nbsp;obj </span><span class="c1">=</span><span class="c3">&nbsp;{</span></p><p class="c2"><span class="c7">&nbsp; &nbsp;name: </span><span class="c8 c10">&#39;johnny&#39;</span></p><p class="c2"><span class="c3">}</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">//call</span></p><p class="c2"><span class="c5">func</span><span class="c7">.</span><span class="c5">call</span><span class="c7">(obj, </span><span class="c8">&#39;straight&#39;</span><span class="c3">)</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">//apply takes in an array of args rather than many args and maps &#39;em with parameters</span></p><p class="c2"><span class="c5">func</span><span class="c7">.</span><span class="c5">apply</span><span class="c7">(obj, [</span><span class="c8">&#39;gay&#39;</span><span class="c3">]);</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">//bind returns a func which when called will actually call the original function</span></p><p class="c2"><span class="c7">(</span><span class="c5">func</span><span class="c7">.</span><span class="c5">bind</span><span class="c7">(obj, </span><span class="c8">&#39;asexual&#39;</span><span class="c3">))();</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">//CURRYING</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">/* Currying is an advanced technique to transform a function of arguments n, to n functions of one or less arguments. Example of a curried function: */</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c1">function</span><span class="c7">&nbsp;</span><span class="c5">add</span><span class="c7">(</span><span class="c9">a</span><span class="c3">) {</span></p><p class="c2"><span class="c7">&nbsp; &nbsp;</span><span class="c1">return</span><span class="c7">&nbsp;</span><span class="c1">function</span><span class="c7">&nbsp;(</span><span class="c9">b</span><span class="c3">) {</span></p><p class="c2"><span class="c7">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1">return</span><span class="c7">&nbsp;</span><span class="c9">a</span><span class="c7">&nbsp;</span><span class="c1">+</span><span class="c7">&nbsp;</span><span class="c9">b</span><span class="c3">;</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;}</span></p><p class="c2"><span class="c3">}</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c5">add</span><span class="c7">(</span><span class="c0">3</span><span class="c7">)(</span><span class="c0">4</span><span class="c3">)</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">/* For Example, if we have a function f(a, b) , then the function after currying, will be transformed to f(a)(b). By using the currying technique, we do not change the functionality of a function, we just change the way it is invoked. Let&rsquo;s see currying in action: */</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c1">function</span><span class="c7">&nbsp;</span><span class="c5">multiply</span><span class="c7">(</span><span class="c9">a</span><span class="c7">, </span><span class="c9">b</span><span class="c3">) {</span></p><p class="c2"><span class="c7">&nbsp; &nbsp;</span><span class="c1">return</span><span class="c7">&nbsp;</span><span class="c9">a</span><span class="c7">&nbsp;</span><span class="c1">*</span><span class="c7">&nbsp;</span><span class="c9">b</span><span class="c3">;</span></p><p class="c2"><span class="c3">}</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c1">function</span><span class="c7">&nbsp;</span><span class="c5">currying</span><span class="c7">(</span><span class="c9">fn</span><span class="c3">) {</span></p><p class="c2"><span class="c7">&nbsp; &nbsp;</span><span class="c1">return</span><span class="c7">&nbsp;</span><span class="c1">function</span><span class="c7">&nbsp;(</span><span class="c9">a</span><span class="c3">) {</span></p><p class="c2"><span class="c7">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1">return</span><span class="c7">&nbsp;</span><span class="c1">function</span><span class="c7">&nbsp;(</span><span class="c9">b</span><span class="c3">) {</span></p><p class="c2"><span class="c7">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1">return</span><span class="c7">&nbsp;</span><span class="c5">fn</span><span class="c7">(</span><span class="c9">a</span><span class="c7">, </span><span class="c9">b</span><span class="c3">);</span></p><p class="c2"><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;}</span></p><p class="c2"><span class="c3">}</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c1">var</span><span class="c7">&nbsp;</span><span class="c5">curriedMultiply</span><span class="c7">&nbsp;</span><span class="c1">=</span><span class="c7">&nbsp;</span><span class="c5">currying</span><span class="c7">(</span><span class="c5">multiply</span><span class="c3">);</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c5">multiply</span><span class="c7">(</span><span class="c0">4</span><span class="c7">, </span><span class="c0">3</span><span class="c7">); </span><span class="c4">// Returns 12</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c5">curriedMultiply</span><span class="c7">(</span><span class="c0">4</span><span class="c7">)(</span><span class="c0">3</span><span class="c7">); </span><span class="c4">// Also returns 12</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">/* As one can see in the code above, we have transformed the function multiply(a, b) to a function curriedMultiply , which takes in one parameter at a time. */</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">//COSURE</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c1">let</span><span class="c7">&nbsp;</span><span class="c5">x</span><span class="c7">&nbsp;</span><span class="c1">=</span><span class="c7">&nbsp;() </span><span class="c1">=&gt;</span><span class="c3">&nbsp;{</span></p><p class="c2"><span class="c7">&nbsp; &nbsp;</span><span class="c1">let</span><span class="c7">&nbsp;y </span><span class="c1">=</span><span class="c7">&nbsp;</span><span class="c8">&#39;4&#39;</span><span class="c3">;</span></p><p class="c2"><span class="c7">&nbsp; &nbsp;</span><span class="c1">return</span><span class="c7">&nbsp;() </span><span class="c1">=&gt;</span><span class="c3">&nbsp;{</span></p><p class="c2"><span class="c7">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c0">console</span><span class="c7">.</span><span class="c5">log</span><span class="c3">(y);</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;}</span></p><p class="c2"><span class="c3">}</span></p><p class="c2"><span class="c5">x</span><span class="c3">()();</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">/* Closure is a prop of js by virtue of which a reference to the lexical scope of a function is attached to it when the func is defined. This scope consists of all the variables required by the func and not defined within it&#39;s own scope.</span></p><p class="c2"><span class="c4">&nbsp; x(), instead of destroying the value of y after execution, saves the value in the memory for further reference. This is the reason why the returning function is able to use the variable declared in the outer scope even after the function is already executed. */</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">//PROTOTYPE</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">/* https://javascript.info/prototypes */</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c1">let</span><span class="c7">&nbsp;arr </span><span class="c1">=</span><span class="c7">&nbsp;[</span><span class="c0">4</span><span class="c7">, </span><span class="c8">&#39;h&#39;</span><span class="c3">];</span></p><p class="c2"><span class="c7">arr.</span><span class="c5">push</span><span class="c7">(</span><span class="c0">false</span><span class="c3">);</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">/* Object has a property(obj) - prototype. Any obj that we create(array, js obj, etc) inherits all the properties from this global Object&#39;s property, prototype obj. But this obj that we create also has a protype of its own, possibly containing props. We can add to these props of this proto. So when we access a property on an obj which possibly we created no failure is resulted unless this prop that we access is neither present in the obj&#39;s proto (or any of the protos that this obj inherits from) nor have we defined it ourselves in the obj. For example, the push on arr works because even though no such function has been defined by us, but its present in the proto of Array obj. */</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">//MEMOIZATION</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">/* Memoization is a form of caching where the return value of a function is cached based on its parameters. If the parameter of that function is not changed, the cached version of the function is returned. Memoization is used for expensive function calls. */</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c1">function</span><span class="c7">&nbsp;</span><span class="c5">addTo256</span><span class="c7">(</span><span class="c9">num</span><span class="c3">) {</span></p><p class="c2"><span class="c7">&nbsp; &nbsp;</span><span class="c1">return</span><span class="c7">&nbsp;</span><span class="c9">num</span><span class="c7">&nbsp;</span><span class="c1">+</span><span class="c7">&nbsp;</span><span class="c0">256</span><span class="c3">;</span></p><p class="c2"><span class="c3">}</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c5">addTo256</span><span class="c7">(</span><span class="c0">20</span><span class="c7">); </span><span class="c4">// Returns 276</span></p><p class="c2"><span class="c5">addTo256</span><span class="c7">(</span><span class="c0">40</span><span class="c7">); </span><span class="c4">// Returns 296</span></p><p class="c2"><span class="c5">addTo256</span><span class="c7">(</span><span class="c0">20</span><span class="c7">); </span><span class="c4">// Returns 276</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">/* When we are calling the function addTo256 again with the same parameter(&ldquo;20&rdquo; in the case above), we are computing the result again for the same parameter. Computing the result with the same parameter again and again is not a big deal in the above case, but imagine if the function does some heavy duty work, then, computing the result again and again with the same parameter will lead to wastage of time. This is where memoization comes in, by using memoization we can store(cache) the computed results based on the parameters.If the same parameter is used again while invoking the function, instead of computing the result, we directly return the stored(cached) value. Let&rsquo;s convert the above function addTo256, to a memoized function: */</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c1">function</span><span class="c7">&nbsp;</span><span class="c5">memoizedAddTo256</span><span class="c3">() {</span></p><p class="c2"><span class="c7">&nbsp; &nbsp;</span><span class="c1">var</span><span class="c7">&nbsp;cache </span><span class="c1">=</span><span class="c3">&nbsp;{};</span></p><p class="c2"><span class="c7">&nbsp; &nbsp;</span><span class="c1">return</span><span class="c7">&nbsp;</span><span class="c1">function</span><span class="c7">&nbsp;(</span><span class="c9">num</span><span class="c3">) {</span></p><p class="c2"><span class="c7">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1">if</span><span class="c7">&nbsp;(</span><span class="c1">!</span><span class="c9">num</span><span class="c7">&nbsp;</span><span class="c1">in</span><span class="c3">&nbsp;cache)</span></p><p class="c2"><span class="c7">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cache[</span><span class="c9">num</span><span class="c7">] </span><span class="c1">=</span><span class="c7">&nbsp;</span><span class="c9">num</span><span class="c7">&nbsp;</span><span class="c1">+</span><span class="c7">&nbsp;</span><span class="c0">256</span><span class="c3">;</span></p><p class="c2"><span class="c7">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1">return</span><span class="c7">&nbsp;cache[</span><span class="c9">num</span><span class="c3">];</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;}</span></p><p class="c2"><span class="c3">}</span></p><p class="c2"><span class="c1">var</span><span class="c7">&nbsp;</span><span class="c5">memoizedFunc</span><span class="c7">&nbsp;</span><span class="c1">=</span><span class="c7">&nbsp;</span><span class="c5">memoizedAddTo256</span><span class="c3">();</span></p><p class="c2"><span class="c5">memoizedFunc</span><span class="c7">(</span><span class="c0">20</span><span class="c7">); </span><span class="c4">// Normal return</span></p><p class="c2"><span class="c5">memoizedFunc</span><span class="c7">(</span><span class="c0">20</span><span class="c7">); </span><span class="c4">// Cached return</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">/* In the code above, if we run memoizedFunc function with the same parameter, instead of computing the result again, it returns the cached result. Although using memoization saves time, it results in larger consumption of memory since we are storing all the computed results. */</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">//ARROW</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">/* By general definition, the this keyword always refers to the object that is calling the function. In the arrow functions, there is no binding of the this keyword. The this keyword inside an arrow function, does not refer to the object calling it. It rather inherits its value from the parent scope. */</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">//REST AND SPREAD</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">/* Rest provides an improved way of handling parameters of a function. Using the rest parameter syntax, we can create functions that can take a variable number of arguments. Any number of arguments will be converted into an array using the rest parameter. It also helps in extracting all or some parts of the arguments. Rest parameter can be used by applying three dots (...) before the parameters. */</span></p><p class="c2"><span class="c1">function</span><span class="c7">&nbsp;</span><span class="c5">extractingArgs</span><span class="c7">(</span><span class="c1">...</span><span class="c9">args</span><span class="c3">) {</span></p><p class="c2"><span class="c7">&nbsp; &nbsp;</span><span class="c1">return</span><span class="c7">&nbsp;</span><span class="c9">args</span><span class="c7">[</span><span class="c0">1</span><span class="c3">];</span></p><p class="c2"><span class="c3">}</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">// extractingArgs(8,9,1); // Returns 9</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c1">function</span><span class="c7">&nbsp;</span><span class="c5">addAllArgs</span><span class="c7">(</span><span class="c1">...</span><span class="c9">args</span><span class="c3">) {</span></p><p class="c2"><span class="c7">&nbsp; &nbsp;</span><span class="c1">let</span><span class="c7">&nbsp;sumOfArgs </span><span class="c1">=</span><span class="c7">&nbsp;</span><span class="c0">0</span><span class="c3">;</span></p><p class="c2"><span class="c7">&nbsp; &nbsp;</span><span class="c1">let</span><span class="c7">&nbsp;i </span><span class="c1">=</span><span class="c7">&nbsp;</span><span class="c0">0</span><span class="c3">;</span></p><p class="c2"><span class="c7">&nbsp; &nbsp;</span><span class="c1">while</span><span class="c7">&nbsp;(i </span><span class="c1">&lt;</span><span class="c7">&nbsp;</span><span class="c9">args</span><span class="c7">.</span><span class="c0">length</span><span class="c3">) {</span></p><p class="c2"><span class="c7">&nbsp; &nbsp; &nbsp; &nbsp;sumOfArgs </span><span class="c1">+=</span><span class="c7">&nbsp;</span><span class="c9">args</span><span class="c3">[i];</span></p><p class="c2"><span class="c7">&nbsp; &nbsp; &nbsp; &nbsp;i</span><span class="c1">++</span><span class="c3">;</span></p><p class="c2"><span class="c3">&nbsp; &nbsp;}</span></p><p class="c2"><span class="c7">&nbsp; &nbsp;</span><span class="c1">return</span><span class="c3">&nbsp;sumOfArgs;</span></p><p class="c2"><span class="c3">}</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c5">addAllArgs</span><span class="c7">(</span><span class="c0">6</span><span class="c7">, </span><span class="c0">5</span><span class="c7">, </span><span class="c0">7</span><span class="c7">, </span><span class="c0">99</span><span class="c7">); </span><span class="c4">// Returns 117</span></p><p class="c2"><span class="c5">addAllArgs</span><span class="c7">(</span><span class="c0">1</span><span class="c7">, </span><span class="c0">3</span><span class="c7">, </span><span class="c0">4</span><span class="c7">); </span><span class="c4">// Returns 8</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">// Rest parameter should always be used at the last parameter of a function:</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">// Incorrect way to use rest parameter</span></p><p class="c2"><span class="c1">function</span><span class="c7">&nbsp;</span><span class="c5">randomFunc</span><span class="c7">(</span><span class="c9">a</span><span class="c7">, </span><span class="c1">...</span><span class="c9">args</span><span class="c7">, </span><span class="c9">c</span><span class="c3">) {</span></p><p class="c2"><span class="c7">&nbsp; &nbsp;</span><span class="c4">//Do something</span></p><p class="c2"><span class="c3">}</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">// Correct way to use rest parameter</span></p><p class="c2"><span class="c1">function</span><span class="c7">&nbsp;</span><span class="c5">randomFunc2</span><span class="c7">(</span><span class="c9">a</span><span class="c7">, </span><span class="c9">b</span><span class="c7">, </span><span class="c1">...</span><span class="c9">args</span><span class="c3">) {</span></p><p class="c2"><span class="c7">&nbsp; &nbsp;</span><span class="c4">//Do something</span></p><p class="c2"><span class="c3">}</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">//GENERATOR`</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">/* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator */</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">//CLASS</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">/* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes */</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">//Object destructuring:</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c1">const</span><span class="c7">&nbsp;</span><span class="c0">classDetails</span><span class="c7">&nbsp;</span><span class="c1">=</span><span class="c3">&nbsp;{</span></p><p class="c2"><span class="c7">&nbsp; &nbsp;strength: </span><span class="c0">78</span><span class="c3">,</span></p><p class="c2"><span class="c7">&nbsp; &nbsp;benches: </span><span class="c0">39</span><span class="c3">,</span></p><p class="c2"><span class="c7">&nbsp; &nbsp;blackBoard: </span><span class="c0 c10">1</span></p><p class="c2"><span class="c3">}</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c1">const</span><span class="c7">&nbsp;{ strength: </span><span class="c0">classStrength</span><span class="c7">, benches: </span><span class="c0">classBenches</span><span class="c7">, blackBoard: </span><span class="c0">classBlackBoard</span><span class="c7">&nbsp;} </span><span class="c1">=</span><span class="c7">&nbsp;</span><span class="c0">classDetails</span><span class="c3">;</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c0">console</span><span class="c7">.</span><span class="c5">log</span><span class="c7">(</span><span class="c0">classStrength</span><span class="c7">); </span><span class="c4">// Outputs 78</span></p><p class="c2"><span class="c0">console</span><span class="c7">.</span><span class="c5">log</span><span class="c7">(</span><span class="c0">classBenches</span><span class="c7">); </span><span class="c4">// Outputs 39</span></p><p class="c2"><span class="c0">console</span><span class="c7">.</span><span class="c5">log</span><span class="c7">(</span><span class="c0">classBlackBoard</span><span class="c7">); </span><span class="c4">// Outputs 1</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">/* As one can see, using object destructuring we have extracted all the elements inside an object in one line of code. If we want our new variable to have the same name as the property of an object we can remove the colon: */</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c1">const</span><span class="c7">&nbsp;{ strength: </span><span class="c0">strength</span><span class="c7">&nbsp;} </span><span class="c1">=</span><span class="c7">&nbsp;</span><span class="c0">classDetails</span><span class="c3">;</span></p><p class="c2"><span class="c4">// The above line of code can be written as:</span></p><p class="c2"><span class="c1">const</span><span class="c7">&nbsp;{ </span><span class="c0">strength</span><span class="c7">&nbsp;} </span><span class="c1">=</span><span class="c7">&nbsp;</span><span class="c0">classDetails</span><span class="c3">;</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">//Array destructuring:</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">/* The same example using object destructuring: */</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c1">const</span><span class="c7">&nbsp;</span><span class="c0">arr</span><span class="c7">&nbsp;</span><span class="c1">=</span><span class="c7">&nbsp;[</span><span class="c0">1</span><span class="c7">, </span><span class="c0">2</span><span class="c7">, </span><span class="c0">3</span><span class="c7">, </span><span class="c0">4</span><span class="c3">];</span></p><p class="c2"><span class="c1">const</span><span class="c7">&nbsp;[</span><span class="c0">first</span><span class="c7">, </span><span class="c0">second</span><span class="c7">, </span><span class="c0">third</span><span class="c7">, </span><span class="c0">fourth</span><span class="c7">] </span><span class="c1">=</span><span class="c3">&nbsp;arr;</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c0">console</span><span class="c7">.</span><span class="c5">log</span><span class="c7">(</span><span class="c0">first</span><span class="c7">); </span><span class="c4">// Outputs 1</span></p><p class="c2"><span class="c0">console</span><span class="c7">.</span><span class="c5">log</span><span class="c7">(</span><span class="c0">second</span><span class="c7">); </span><span class="c4">// Outputs 2</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">//TEMPORAL DEAD ZONE</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">/* Temporal Dead Zone is a behaviour that occurs with variables declared using let and const keywords.</span></p><p class="c2 c6"><span class="c3"></span></p><p class="c2"><span class="c4">It is a behaviour where we try to access a variable before it is initialized. */</span></p></body></html>